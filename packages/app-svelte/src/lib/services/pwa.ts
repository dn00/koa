/**
 * PWA Support Service
 *
 * Provides service worker registration, update notifications,
 * and install prompt handling for Progressive Web App functionality.
 */

/**
 * PWA state interface
 */
export interface PWAState {
	isSupported: boolean;
	isInstalled: boolean;
	hasUpdate: boolean;
	isOnline: boolean;
}

/**
 * Service worker registration result
 */
export interface SWRegistration {
	active: ServiceWorker | null;
	installing: ServiceWorker | null;
	waiting: ServiceWorker | null;
	update: () => Promise<void>;
}

/**
 * Install prompt handler
 */
export interface InstallPromptHandler {
	prompt: BeforeInstallPromptEvent | null;
	setPrompt: (event: BeforeInstallPromptEvent | null) => void;
}

/**
 * BeforeInstallPromptEvent interface (not in standard lib.dom.d.ts)
 */
export interface BeforeInstallPromptEvent extends Event {
	readonly platforms: string[];
	readonly userChoice: Promise<{
		outcome: 'accepted' | 'dismissed';
		platform: string;
	}>;
	prompt(): Promise<void>;
}

/**
 * Update notifier interface
 */
export interface UpdateNotifier {
	onUpdateAvailable: (callback: () => void) => void;
	checkNow: () => Promise<boolean>;
	skipWaiting: () => void;
}

// Store install prompt event
let deferredInstallPrompt: BeforeInstallPromptEvent | null = null;

/**
 * Check if service worker is supported in current environment
 */
export function isServiceWorkerSupported(): boolean {
	return typeof navigator !== 'undefined' && 'serviceWorker' in navigator;
}

/**
 * Check if app is running in installed/standalone mode
 */
export function isAppInstalled(): boolean {
	if (typeof window === 'undefined') return false;

	// Check display-mode media query
	const isStandalone = window.matchMedia('(display-mode: standalone)').matches;

	// Also check iOS Safari standalone mode
	const isIOSStandalone =
		'standalone' in window.navigator &&
		(window.navigator as Navigator & { standalone?: boolean }).standalone === true;

	return isStandalone || isIOSStandalone;
}

/**
 * Register the service worker
 * Returns registration object or null if not supported
 */
export async function registerServiceWorker(): Promise<SWRegistration | null> {
	if (!isServiceWorkerSupported()) {
		return null;
	}

	try {
		// Register the service worker generated by vite-pwa
		const registration = await navigator.serviceWorker.register('/sw.js', {
			scope: '/'
		});

		return {
			active: registration.active,
			installing: registration.installing,
			waiting: registration.waiting,
			update: async () => {
				await registration.update();
			}
		};
	} catch (error) {
		console.error('Service worker registration failed:', error);
		return null;
	}
}

/**
 * Check if an update is available (waiting worker)
 */
export async function checkForUpdate(): Promise<boolean> {
	if (!isServiceWorkerSupported()) {
		return false;
	}

	try {
		const registration = await navigator.serviceWorker.getRegistration();
		if (!registration) return false;

		// Check for waiting worker
		if (registration.waiting) {
			return true;
		}

		// Check for update
		await registration.update();

		// Re-check after update
		return registration.waiting !== null;
	} catch {
		return false;
	}
}

/**
 * Create an update notifier for handling SW updates
 */
export function createUpdateNotifier(): UpdateNotifier {
	let updateCallback: (() => void) | null = null;
	let waitingWorker: ServiceWorker | null = null;

	return {
		onUpdateAvailable(callback: () => void) {
			updateCallback = callback;
		},

		async checkNow(): Promise<boolean> {
			if (!isServiceWorkerSupported()) {
				return false;
			}

			try {
				const registration = await navigator.serviceWorker.getRegistration();
				if (!registration) return false;

				// Check if there's a waiting worker
				if (registration.waiting) {
					waitingWorker = registration.waiting;
					updateCallback?.();
					return true;
				}

				// Try to update
				await registration.update();

				// Listen for updatefound
				return new Promise((resolve) => {
					if (registration.installing) {
						const newWorker = registration.installing;
						newWorker.addEventListener('statechange', () => {
							if (newWorker.state === 'installed' && registration.waiting) {
								waitingWorker = registration.waiting;
								updateCallback?.();
								resolve(true);
							}
						});
					} else if (registration.waiting) {
						waitingWorker = registration.waiting;
						updateCallback?.();
						resolve(true);
					} else {
						resolve(false);
					}
				});
			} catch {
				return false;
			}
		},

		skipWaiting() {
			if (waitingWorker) {
				waitingWorker.postMessage({ type: 'SKIP_WAITING' });
			}
		}
	};
}

/**
 * Get install prompt handler
 * Call setPrompt when beforeinstallprompt event fires
 */
export function getInstallPrompt(): InstallPromptHandler {
	return {
		get prompt() {
			return deferredInstallPrompt;
		},
		setPrompt(event: BeforeInstallPromptEvent | null) {
			deferredInstallPrompt = event;
		}
	};
}

/**
 * Setup beforeinstallprompt listener
 * Should be called once on app mount
 */
export function setupInstallPromptListener(): void {
	if (typeof window === 'undefined') return;

	window.addEventListener('beforeinstallprompt', (e) => {
		// Prevent Chrome 67+ from automatically showing the prompt
		e.preventDefault();
		// Store the event for later use
		deferredInstallPrompt = e as BeforeInstallPromptEvent;
	});
}

/**
 * Trigger the install prompt
 * Returns user choice or null if prompt not available
 */
export async function triggerInstallPrompt(): Promise<{
	outcome: 'accepted' | 'dismissed';
	platform: string;
} | null> {
	if (!deferredInstallPrompt) {
		return null;
	}

	// Show the prompt
	await deferredInstallPrompt.prompt();

	// Wait for user choice
	const choice = await deferredInstallPrompt.userChoice;

	// Clear the prompt
	deferredInstallPrompt = null;

	return choice;
}

/**
 * Create online/offline state tracker
 */
export function createOnlineTracker(): {
	isOnline: () => boolean;
	onStatusChange: (callback: (online: boolean) => void) => () => void;
} {
	const callbacks: Set<(online: boolean) => void> = new Set();

	if (typeof window !== 'undefined') {
		window.addEventListener('online', () => {
			callbacks.forEach((cb) => cb(true));
		});
		window.addEventListener('offline', () => {
			callbacks.forEach((cb) => cb(false));
		});
	}

	return {
		isOnline: () => (typeof navigator !== 'undefined' ? navigator.onLine : true),
		onStatusChange(callback: (online: boolean) => void) {
			callbacks.add(callback);
			return () => callbacks.delete(callback);
		}
	};
}
